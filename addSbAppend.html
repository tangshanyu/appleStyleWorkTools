<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL 轉 Java sb.append() 工具</title>
    <link rel="stylesheet" href="shared-styles.css">
    <script src="https://cdn.jsdelivr.net/npm/sql-formatter/dist/sql-formatter.min.js"></script>
    <script src="shared-navigation.js"></script>
    <style>
        .header.theme-orange {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.12) 0%, rgba(251, 146, 60, 0.1) 100%);
        }
        
        .btn.theme-orange {
            background: linear-gradient(135deg, var(--theme-orange) 0%, #f97316 100%);
        }
        
        .btn.theme-orange:hover {
            box-shadow: 0 8px 25px rgba(249, 115, 22, 0.3);
        }
        
        .format-info {
            background: rgba(251, 191, 36, 0.05);
            border: 1px solid rgba(251, 191, 36, 0.15);
            border-radius: var(--border-radius-small);
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        #sqlInput, .output {
            font-family: 'Courier New', Consolas, 'Lucida Console', monospace;
            tab-size: 4;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header theme-orange">
            <h1>SQL 轉 Java sb.append()</h1>
            <p>精準 SQL 格式化工具，完美匹配標準格式</p>
        </div>
        
        <nav class="nav">
            <!-- 共用導覽將由 JavaScript 自動載入 -->
        </nav>
        
        <div class="content">
            <div class="alert alert-info">
                <strong>✨ 使用說明：</strong>
                輸入 SQL 語句，工具會精準格式化為標準格式，包括正確的 Tab 縮排、逗號前置、註釋保留和子查詢處理。
            </div>
            
            <div class="form-group">
                <label for="sqlInput">📝 輸入 SQL：</label>
                <textarea id="sqlInput" class="form-control" placeholder="請輸入 SQL 語句..." rows="20" style="font-family: 'Courier New', monospace; tab-size: 4;"></textarea>
            </div>
            
            <div class="format-info">
                <strong>💡 精準格式：</strong> 完全符合標準格式，包括獨立註釋行、子查詢縮排、CASE 語句對齊。
            </div>
            
            <div class="checkbox-group">
                <div class="checkbox-item">
                    <input type="checkbox" id="camelCaseAsCheckbox">
                    <label for="camelCaseAsCheckbox">🐪 SELECT 欄位使用駝峰命名 AS 別名</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="hibernateCheckbox">
                    <label for="hibernateCheckbox">🏗️ 產生 HibernateScalarHelper</label>
                </div>
            </div>
            
            <div class="button-group">
                <button id="convertSqlBtn" class="btn theme-orange">🚀 轉換</button>
                <button id="formatOnlyBtn" class="btn">🎨 僅格式化 SQL</button>
                <button id="clearBtn" class="btn">🗑️ 清空</button>
            </div>
            
            <div class="results-layout">
                <div class="output-section">
                    <div class="form-group">
                        <label>⚡ sb.append() 結果：</label>
                        <div id="sbAppendOutput" class="output">sb.append() 結果將在這裡顯示...</div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-success copy-button" data-copy-target="sbAppendOutput">📋 複製</button>
                    </div>
                </div>
                
                <div class="output-section">
                    <div class="form-group">
                        <label>🏗️ HibernateScalarHelper List：</label>
                        <div id="hibernateOutput" class="output">HibernateScalarHelper 結果將在這裡顯示...</div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-success copy-button" data-copy-target="hibernateOutput">📋 複製</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // 精準欄位解析 - 完全符合標準
        function parseFieldsAdvanced(content) {
            const fields = [];
            let current = '';
            let parens = 0;
            let inQuotes = false;
            let quoteChar = '';
            let inBlockComment = false;
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                const nextChar = i < content.length - 1 ? content[i + 1] : '';
                
                // 處理塊註釋
                if (!inQuotes && char === '/' && nextChar === '*') {
                    inBlockComment = true;
                    current += char;
                } else if (inBlockComment && char === '*' && nextChar === '/') {
                    inBlockComment = false;
                    current += char + nextChar;
                    i++; // 跳過下一個字符
                } else if (inBlockComment) {
                    current += char;
                }
                // 處理引號
                else if (!inBlockComment && (char === '"' || char === "'")) {
                    if (!inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = '';
                    }
                    current += char;
                }
                // 處理括號
                else if (!inQuotes && !inBlockComment && char === '(') {
                    parens++;
                    current += char;
                } else if (!inQuotes && !inBlockComment && char === ')') {
                    parens--;
                    current += char;
                }
                // 處理逗號分隔符
                else if (!inQuotes && !inBlockComment && char === ',' && parens === 0) {
                    const trimmedField = current.trim();
                    if (trimmedField) {
                        fields.push(trimmedField);
                    }
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // 加入最後一個欄位
            const trimmedField = current.trim();
            if (trimmedField) {
                fields.push(trimmedField);
            }
            
            return fields;
        }

        // 關鍵字大寫處理
        function uppercaseKeywords(sql) {
            const keywords = [
                'SELECT', 'FROM', 'WHERE', 'ORDER BY', 'GROUP BY', 'HAVING', 
                'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'ALTER', 'DROP',
                'INNER JOIN', 'LEFT JOIN', 'RIGHT JOIN', 'FULL JOIN', 'JOIN',
                'UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT',
                'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN',
                'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
                'AS', 'IS', 'NULL', 'TRUE', 'FALSE',
                'DISTINCT', 'TOP', 'LIMIT', 'OFFSET',
                'INTO', 'VALUES', 'SET'
            ];
            
            keywords.forEach(keyword => {
                const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                sql = sql.replace(regex, keyword);
            });
            
            return sql;
        }

        // 主要格式化函數 - 精準標準格式
        function formatSqlAdvanced(sql) {
            console.log('開始處理 SQL:', sql);
            
            // 先處理關鍵字大寫
            sql = uppercaseKeywords(sql);
            
            // 使用標準格式化器建立基本結構
            try {
                sql = window.sqlFormatter.format(sql, {
                    language: 'sql',
                    keywordCase: 'upper',
                    indentStyle: 'tabbed',
                    logicalOperatorNewline: 'before'
                });
                console.log('標準格式化後:', sql);
            } catch (error) {
                console.warn('格式化器失敗，使用原始 SQL');
            }
            
            // 精準後處理 - 完全符合標準格式
            sql = precisionPostProcess(sql);
            
            console.log('最終結果:', sql);
            return sql;
        }

        // 精準後處理 - 完全符合標準格式
        function precisionPostProcess(sql) {
            const lines = sql.split('\n');
            const result = [];
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trim();
                const upperTrimmed = trimmed.toUpperCase();
                
                // 處理 SELECT 語句
                if (upperTrimmed === 'SELECT' || upperTrimmed.startsWith('SELECT ')) {
                    const selectResult = processSelectClause(lines, i);
                    result.push(...selectResult.lines);
                    i = selectResult.nextIndex;
                }
                // 處理 GROUP BY 語句
                else if (upperTrimmed === 'GROUP BY' || upperTrimmed.startsWith('GROUP BY ')) {
                    const groupResult = processGroupByClause(lines, i);
                    result.push(...groupResult.lines);
                    i = groupResult.nextIndex;
                }
                // 處理 ORDER BY 語句
                else if (upperTrimmed === 'ORDER BY' || upperTrimmed.startsWith('ORDER BY ')) {
                    const orderResult = processOrderByClause(lines, i);
                    result.push(...orderResult.lines);
                    i = orderResult.nextIndex;
                }
                // 處理包含子查詢的行
                else if (containsSubquery(line)) {
                    const subqueryResult = processSubqueryLine(line);
                    result.push(...subqueryResult);
                    i++;
                }
                // 其他行直接保留
                else {
                    result.push(line);
                    i++;
                }
            }
            
            return result.join('\n');
        }

        // 檢查是否包含子查詢
        function containsSubquery(line) {
            return /FROM\s*\(\s*SELECT/i.test(line) || 
                   /JOIN\s*\(\s*SELECT/i.test(line) ||
                   /\(\s*SELECT/i.test(line);
        }

        // 處理包含子查詢的行
        function processSubqueryLine(line) {
            const result = [];
            const baseIndent = line.match(/^(\s*)/)[1];
            
            // 匹配 "FROM ( SELECT ..." 模式
            const subqueryMatch = line.match(/^(.+?)\(\s*(SELECT.+)$/i);
            if (subqueryMatch) {
                const beforeSelect = subqueryMatch[1].trim();
                const selectContent = subqueryMatch[2];
                
                // 添加 FROM ( 部分
                result.push(baseIndent + beforeSelect + '(');
                
                // 處理子查詢 SELECT 部分
                const subqueryLines = processSubquerySelect(selectContent, baseIndent + '\t');
                result.push(...subqueryLines);
                
                return result;
            }
            
            return [line];
        }

        // 處理子查詢中的 SELECT
        function processSubquerySelect(selectContent, baseIndent) {
            const result = [];
            
            // 移除可能的結尾括號和其他內容
            let cleanSelect = selectContent;
            let remainingContent = '';
            
            // 尋找 FROM 關鍵字來分離欄位部分
            const fromMatch = cleanSelect.match(/^(SELECT\s+.+?)\s+(FROM\s+.+)$/i);
            if (fromMatch) {
                cleanSelect = fromMatch[1];
                remainingContent = fromMatch[2];
            }
            
            // 處理 SELECT 部分
            const selectMatch = cleanSelect.match(/^(SELECT)\s*(.*)$/i);
            if (selectMatch) {
                result.push(baseIndent + 'SELECT');
                
                const fieldsContent = selectMatch[2].trim();
                if (fieldsContent) {
                    const fields = parseFieldsAdvanced(fieldsContent);
                    
                    fields.forEach((field, index) => {
                        // 檢查是否是純註釋欄位（如 /*1202-3000 可轉債－成本*/）
                        if (field.trim().startsWith('/*') && field.trim().endsWith('*/') && !field.includes('AS') && !field.includes('.')) {
                            if (index === 0) {
                                result.push(baseIndent + '\t' + field);
                            } else {
                                result.push(baseIndent + '\t,' + field);
                            }
                        } else {
                            if (index === 0) {
                                result.push(baseIndent + '\t' + field);
                            } else {
                                result.push(baseIndent + '\t,' + field);
                            }
                        }
                    });
                }
            }
            
            // 處理剩餘內容（FROM 等）
            if (remainingContent) {
                const remainingLines = remainingContent.split(/\s+(?=FROM|WHERE|GROUP BY|ORDER BY|HAVING|JOIN|LEFT JOIN|RIGHT JOIN|INNER JOIN)/i);
                remainingLines.forEach(line => {
                    if (line.trim()) {
                        result.push(baseIndent + line.trim());
                    }
                });
            }
            
            return result;
        }

        // 處理 SELECT 子句
        function processSelectClause(lines, startIndex) {
            const selectLine = lines[startIndex];
            const baseIndent = selectLine.match(/^(\s*)/)[1];
            const result = [];
            
            // SELECT 關鍵字
            result.push(baseIndent + 'SELECT');
            
            // 收集所有相關行
            let i = startIndex + 1;
            let allContent = '';
            const commentLines = [];
            
            // 處理 SELECT 行本身的內容
            const selectMatch = selectLine.match(/^\s*SELECT\s*(.*)$/i);
            if (selectMatch && selectMatch[1].trim()) {
                allContent = selectMatch[1].trim();
            }
            
            // 收集後續行
            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trim();
                const upperTrimmed = trimmed.toUpperCase();
                
                // 停止條件
                if (trimmed === '' || 
                    upperTrimmed.startsWith('FROM ') || 
                    upperTrimmed.startsWith('WHERE ') ||
                    upperTrimmed.startsWith('GROUP BY') ||
                    upperTrimmed.startsWith('HAVING ') ||
                    upperTrimmed.startsWith('ORDER BY') ||
                    upperTrimmed.startsWith('UNION ') ||
                    upperTrimmed.startsWith('SELECT ') ||
                    upperTrimmed === ')' ||
                    (upperTrimmed.startsWith(')') && upperTrimmed.length > 1)) {
                    break;
                }
                
                // 檢查是否是獨立註釋行
                if (trimmed.startsWith('/*') && trimmed.endsWith('*/') && !trimmed.includes(',') && !trimmed.includes('AS')) {
                    commentLines.push({ index: i, content: trimmed, position: allContent ? 'middle' : 'start' });
                } else if (trimmed) {
                    // 累積欄位內容
                    if (allContent) {
                        allContent += ' ' + trimmed;
                    } else {
                        allContent = trimmed;
                    }
                }
                
                i++;
            }
            
            // 處理註釋和欄位
            if (commentLines.length > 0 && commentLines[0].position === 'start') {
                // 第一個是註釋行
                result.push(baseIndent + '\t' + commentLines[0].content);
                commentLines.shift();
            }
            
            // 處理欄位
            if (allContent.trim()) {
                const fields = parseFieldsAdvanced(allContent);
                
                fields.forEach((field, index) => {
                    // 檢查是否需要插入中間註釋
                    const middleComments = commentLines.filter(c => c.position === 'middle');
                    if (middleComments.length > 0 && index === Math.floor(fields.length / 2)) {
                        result.push(baseIndent + '\t' + middleComments[0].content);
                    }
                    
                    if (index === 0) {
                        result.push(baseIndent + '\t' + field);
                    } else {
                        result.push(baseIndent + '\t,' + field);
                    }
                });
            }
            
            // 處理剩餘的註釋行
            commentLines.forEach(comment => {
                if (comment.position === 'middle') {
                    result.push(baseIndent + '\t' + comment.content);
                }
            });
            
            return {
                lines: result,
                nextIndex: i
            };
        }

        // 處理 GROUP BY 子句
        function processGroupByClause(lines, startIndex) {
            return processFieldsClause(lines, startIndex, 'GROUP BY');
        }

        // 處理 ORDER BY 子句
        function processOrderByClause(lines, startIndex) {
            return processFieldsClause(lines, startIndex, 'ORDER BY');
        }

        // 統一處理欄位子句
        function processFieldsClause(lines, startIndex, keyword) {
            const line = lines[startIndex];
            const baseIndent = line.match(/^(\s*)/)[1];
            const result = [baseIndent + keyword];
            
            // 提取關鍵字後的內容
            const regex = new RegExp(`^\\s*(${keyword})\\s*(.*)$`, 'i');
            const match = line.match(regex);
            
            let content = '';
            if (match && match[2].trim()) {
                content = match[2].trim();
            }
            
            // 收集多行內容
            let i = startIndex + 1;
            const stopKeywords = ['ORDER BY', 'GROUP BY', 'HAVING', 'UNION', 'SELECT', ')'];
            
            while (i < lines.length) {
                const nextLine = lines[i];
                const nextTrimmed = nextLine.trim();
                
                if (nextTrimmed === '' || stopKeywords.some(kw => nextTrimmed.toUpperCase().startsWith(kw))) {
                    break;
                }
                
                if (nextTrimmed) {
                    content += (content ? ' ' : '') + nextTrimmed;
                }
                i++;
            }
            
            // 處理欄位
            if (content.trim()) {
                const fields = parseFieldsAdvanced(content);
                fields.forEach((field, index) => {
                    if (index === 0) {
                        result.push(baseIndent + '\t' + field);
                    } else {
                        result.push(baseIndent + '\t,' + field);
                    }
                });
            }
            
            return {
                lines: result,
                nextIndex: i
            };
        }

        function initializeAddSbAppendTool() {
            const convertBtn = document.getElementById('convertSqlBtn');
            const formatOnlyBtn = document.getElementById('formatOnlyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyButtons = document.querySelectorAll('.copy-button');
            
            if (convertBtn) convertBtn.addEventListener('click', convertSql);
            if (formatOnlyBtn) formatOnlyBtn.addEventListener('click', formatSqlOnly);
            if (clearBtn) clearBtn.addEventListener('click', clearAll);
            
            copyButtons.forEach(button => {
                const targetId = button.dataset.copyTarget;
                if (targetId) {
                    button.addEventListener('click', () => copyToClipboard(targetId));
                }
            });
        }

        // 僅格式化 SQL
        function formatSqlOnly() {
            const sqlInput = document.getElementById('sqlInput');
            const sql = sqlInput.value.trim();
            
            if (!sql) {
                alert('請先輸入 SQL 語句');
                return;
            }
            
            const formattedSql = formatSqlAdvanced(sql);
            sqlInput.value = formattedSql;
        }

        // 清空所有內容
        function clearAll() {
            document.getElementById('sqlInput').value = '';
            document.getElementById('sbAppendOutput').textContent = 'sb.append() 結果將在這裡顯示...';
            document.getElementById('hibernateOutput').textContent = 'HibernateScalarHelper 結果將在這裡顯示...';
            document.getElementById('camelCaseAsCheckbox').checked = false;
            document.getElementById('hibernateCheckbox').checked = false;
        }

        // 駝峰命名轉換
        function toCamelCase(str) {
            return str.split('_').map((word, index) => {
                if (index === 0) {
                    return word.toLowerCase();
                }
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }).join('');
        }

        // 檢查是否為 nam 相關欄位
        function isNamField(fieldName) {
            const lowerFieldName = fieldName.toLowerCase();
            return lowerFieldName.includes('nam') || 
                   lowerFieldName.includes('name') ||
                   lowerFieldName.startsWith('nam_') ||
                   lowerFieldName.endsWith('_nam') ||
                   lowerFieldName.startsWith('name_') ||
                   lowerFieldName.endsWith('_name');
        }

        // 提取註釋
        function extractComments(line) {
            const result = {
                code: line,
                comment: '',
                hasComment: false
            };

            // 處理 -- 註釋
            const singleLineCommentMatch = line.match(/^(.*?)--(.*)$/);
            if (singleLineCommentMatch) {
                result.code = singleLineCommentMatch[1].trimEnd();
                result.comment = singleLineCommentMatch[2].trim();
                result.hasComment = true;
            }

            return result;
        }

        // 解析 SELECT 欄位（用於 Hibernate）
        function parseSelectFields(sql) {
            try {
                let cleanSql = sql.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
                
                const selectMatch = cleanSql.match(/\bSELECT\s+([\s\S]+?)(?:\s+FROM\b|\s+INTO\b|\s*$)/i);
                
                if (!selectMatch) {
                    return [];
                }
                
                const fieldsText = selectMatch[1].trim();
                return parseFieldsAdvanced(fieldsText);
            } catch (error) {
                console.error('解析 SELECT 欄位時發生錯誤:', error);
                return [];
            }
        }

        // 處理駝峰命名
        function addCamelCaseAS(sql) {
            const lines = sql.split('\n');
            let inSelectClause = false;
            
            const processedLines = lines.map(line => {
                const trimmed = line.trim().toUpperCase();
                
                if (trimmed.startsWith('SELECT')) {
                    inSelectClause = true;
                } else if (inSelectClause && (trimmed.startsWith('FROM') || trimmed.startsWith('WHERE') || trimmed.startsWith('GROUP BY'))) {
                    inSelectClause = false;
                }
                
                if (inSelectClause && !trimmed.startsWith('SELECT') && trimmed !== '') {
                    return processSelectLine(line);
                }
                
                return line;
            });
            
            return processedLines.join('\n');
        }

        function processSelectLine(line) {
            const commentInfo = extractComments(line);
            let codePart = commentInfo.code;
            const indent = line.match(/^(\s*)/)[1];
            const cleanCode = codePart.trim();
            
            if (cleanCode.toUpperCase().includes(' AS ')) {
                return line;
            }
            
            // 檢查是否以逗號開頭
            let processedCode = cleanCode.replace(/^,\s*/, '');
            const hasComma = cleanCode.startsWith(',');
            
            const fields = parseFieldsAdvanced(processedCode);
            const processedFields = fields.map(field => processField(field.trim()));
            
            let result = processedFields.join(', ');
            if (hasComma) {
                result = ',' + result;
            }
            
            let finalResult = indent + result;
            
            if (commentInfo.hasComment) {
                finalResult += ' --' + commentInfo.comment;
            }
            
            return finalResult;
        }

        function processField(fieldText) {
            if (fieldText.toUpperCase().includes(' AS ')) {
                return fieldText;
            }
            
            let fieldName = fieldText;
            
            const functionMatch = fieldName.match(/(\w+)\s*\(\s*([^)]+)\s*\)/);
            if (functionMatch) {
                const innerContent = functionMatch[2].trim();
                if (innerContent.includes('.')) {
                    fieldName = innerContent.split('.').pop();
                } else {
                    fieldName = innerContent;
                }
            } else if (fieldName.includes('.')) {
                fieldName = fieldName.split('.').pop();
            }
            
            fieldName = fieldName.replace(/[^\w]/g, '');
            
            if (!isNamField(fieldName) && fieldName.includes('_')) {
                const camelCaseName = toCamelCase(fieldName);
                return `${fieldText} AS ${camelCaseName}`;
            }
            
            return fieldText;
        }

        // 主要轉換函數
        function convertSql() {
            let sql = document.getElementById("sqlInput")?.value || "";
            const useCamelCaseAs = document.getElementById('camelCaseAsCheckbox')?.checked || false;
            const generateHibernate = document.getElementById('hibernateCheckbox')?.checked || false;
            
            if (!sql.trim()) {
                alert("請輸入 SQL 語句");
                return;
            }
            
            console.log('原始 SQL:', sql);
            
            // 1. 格式化 SQL
            sql = formatSqlAdvanced(sql);
            console.log('格式化後 SQL:', sql);
            
            // 2. 如果啟用駝峰命名，處理 AS 別名
            if (useCamelCaseAs) {
                sql = addCamelCaseAS(sql);
                console.log('駝峰處理後 SQL:', sql);
            }
            
            // 3. 轉換為 sb.append() 格式
            const lines = sql.split('\n');
            const sbAppendResult = [];
            
            lines.forEach(line => {
                if (!line.trim()) return;
                
                const commentInfo = extractComments(line);
                const code = commentInfo.code.trim();
                
                if (code) {
                    const escapedCode = code.replace(/"/g, '\\"');
                    const originalIndent = line.match(/^(\s*)/)[1];
                    let appendStatement = `sb.append("${originalIndent}${escapedCode} ");`;
                    
                    if (commentInfo.hasComment && commentInfo.comment) {
                        appendStatement += ` // ${commentInfo.comment}`;
                    }
                    
                    sbAppendResult.push(appendStatement);
                }
            });
            
            console.log('sb.append 結果:', sbAppendResult);
            document.getElementById("sbAppendOutput").textContent = sbAppendResult.join('\n');
            
            // 4. 生成 HibernateScalarHelper
            if (generateHibernate) {
                generateHibernateHelper(sql);
            } else {
                document.getElementById("hibernateOutput").textContent = "請勾選「產生 HibernateScalarHelper」選項";
            }
        }

        function generateHibernateHelper(sql) {
            try {
                const selectFields = parseSelectFields(sql);
                
                if (selectFields.length === 0) {
                    document.getElementById("hibernateOutput").textContent = "無法識別 SELECT 語句，請檢查 SQL 格式";
                    return;
                }
                
                const fields = selectFields.map(field => {
                    const trimmed = field.trim();
                    const commentInfo = extractComments(trimmed);
                    const cleanField = commentInfo.code.trim();
                    
                    const asMatch = cleanField.match(/\s+AS\s+(\w+)/i);
                    if (asMatch) {
                        return asMatch[1];
                    }
                    
                    let fieldName = cleanField;
                    
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop();
                    }
                    
                    fieldName = fieldName.replace(/[^\w]/g, '');
                    
                    return fieldName;
                }).filter(field => field && field.trim() !== '');
                
                if (fields.length > 0) {
                    const hibernateList = fields.map(field => 
                        `scalarList.add(new HibernateScalarHelper("${field}", StandardBasicTypes.STRING));`
                    ).join('\n');
                    
                    const hibernateResult = `List<HibernateScalarHelper> scalarList = new ArrayList<>();\n${hibernateList}`;
                    document.getElementById("hibernateOutput").textContent = hibernateResult;
                } else {
                    document.getElementById("hibernateOutput").textContent = "無法提取到有效的欄位名";
                }
            } catch (error) {
                console.error('生成 HibernateScalarHelper 時發生錯誤:', error);
                document.getElementById("hibernateOutput").textContent = "生成 HibernateScalarHelper 時發生錯誤：" + error.message;
            }
        }

        function copyToClipboard(id) {
            const element = document.getElementById(id);
            if (element) {
                const text = element.textContent;
                if (text && !text.includes("將在這裡顯示") && !text.includes("請勾選")) {
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            const btn = document.querySelector(`[data-copy-target="${id}"]`);
                            const originalText = btn.textContent;
                            btn.textContent = '✅ 已複製！';
                            btn.style.background = 'linear-gradient(135deg, #16a34a 0%, #22c55e 100%)';
                            
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.style.background = '';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('複製失敗:', err);
                            alert("複製失敗，請手動複製");
                        });
                } else {
                    alert("沒有可複製的內容");
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initializeAddSbAppendTool();
        });
    </script>
</body>
</html>