<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL è½‰ Java sb.append() å·¥å…·</title>
    <link rel="stylesheet" href="shared-styles.css">
    <script src="https://cdn.jsdelivr.net/npm/sql-formatter/dist/sql-formatter.min.js"></script>
    <script src="shared-navigation.js"></script>
    <style>
        .header.theme-orange {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.12) 0%, rgba(251, 146, 60, 0.1) 100%);
        }
        
        .btn.theme-orange {
            background: linear-gradient(135deg, var(--theme-orange) 0%, #f97316 100%);
        }
        
        .btn.theme-orange:hover {
            box-shadow: 0 8px 25px rgba(249, 115, 22, 0.3);
        }
        
        .format-info {
            background: rgba(251, 191, 36, 0.05);
            border: 1px solid rgba(251, 191, 36, 0.15);
            border-radius: var(--border-radius-small);
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        #sqlInput, .output {
            font-family: 'Courier New', Consolas, 'Lucida Console', monospace;
            tab-size: 4;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header theme-orange">
            <h1>SQL è½‰ Java sb.append()</h1>
            <p>ç²¾æº– SQL æ ¼å¼åŒ–å·¥å…·ï¼Œå®Œç¾åŒ¹é…æ¨™æº–æ ¼å¼</p>
        </div>
        
        <nav class="nav">
            <!-- å…±ç”¨å°è¦½å°‡ç”± JavaScript è‡ªå‹•è¼‰å…¥ -->
        </nav>
        
        <div class="content">
            <div class="alert alert-info">
                <strong>âœ¨ ä½¿ç”¨èªªæ˜ï¼š</strong>
                è¼¸å…¥ SQL èªå¥ï¼Œå·¥å…·æœƒç²¾æº–æ ¼å¼åŒ–ç‚ºæ¨™æº–æ ¼å¼ï¼ŒåŒ…æ‹¬æ­£ç¢ºçš„ Tab ç¸®æ’ã€é€—è™Ÿå‰ç½®ã€è¨»é‡‹ä¿ç•™å’Œå­æŸ¥è©¢è™•ç†ã€‚
            </div>
            
            <div class="form-group">
                <label for="sqlInput">ğŸ“ è¼¸å…¥ SQLï¼š</label>
                <textarea id="sqlInput" class="form-control" placeholder="è«‹è¼¸å…¥ SQL èªå¥..." rows="20" style="font-family: 'Courier New', monospace; tab-size: 4;"></textarea>
            </div>
            
            <div class="format-info">
                <strong>ğŸ’¡ ç²¾æº–æ ¼å¼ï¼š</strong> å®Œå…¨ç¬¦åˆæ¨™æº–æ ¼å¼ï¼ŒåŒ…æ‹¬ç¨ç«‹è¨»é‡‹è¡Œã€å­æŸ¥è©¢ç¸®æ’ã€CASE èªå¥å°é½Šã€‚
            </div>
            
            <div class="checkbox-group">
                <div class="checkbox-item">
                    <input type="checkbox" id="camelCaseAsCheckbox">
                    <label for="camelCaseAsCheckbox">ğŸª SELECT æ¬„ä½ä½¿ç”¨é§å³°å‘½å AS åˆ¥å</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="hibernateCheckbox">
                    <label for="hibernateCheckbox">ğŸ—ï¸ ç”¢ç”Ÿ HibernateScalarHelper</label>
                </div>
            </div>
            
            <div class="button-group">
                <button id="convertSqlBtn" class="btn theme-orange">ğŸš€ è½‰æ›</button>
                <button id="formatOnlyBtn" class="btn">ğŸ¨ åƒ…æ ¼å¼åŒ– SQL</button>
                <button id="clearBtn" class="btn">ğŸ—‘ï¸ æ¸…ç©º</button>
            </div>
            
            <div class="results-layout">
                <div class="output-section">
                    <div class="form-group">
                        <label>âš¡ sb.append() çµæœï¼š</label>
                        <div id="sbAppendOutput" class="output">sb.append() çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º...</div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-success copy-button" data-copy-target="sbAppendOutput">ğŸ“‹ è¤‡è£½</button>
                    </div>
                </div>
                
                <div class="output-section">
                    <div class="form-group">
                        <label>ğŸ—ï¸ HibernateScalarHelper Listï¼š</label>
                        <div id="hibernateOutput" class="output">HibernateScalarHelper çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º...</div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-success copy-button" data-copy-target="hibernateOutput">ğŸ“‹ è¤‡è£½</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // ç²¾æº–æ¬„ä½è§£æ - å®Œå…¨ç¬¦åˆæ¨™æº–
        function parseFieldsAdvanced(content) {
            const fields = [];
            let current = '';
            let parens = 0;
            let inQuotes = false;
            let quoteChar = '';
            let inBlockComment = false;
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                const nextChar = i < content.length - 1 ? content[i + 1] : '';
                
                // è™•ç†å¡Šè¨»é‡‹
                if (!inQuotes && char === '/' && nextChar === '*') {
                    inBlockComment = true;
                    current += char;
                } else if (inBlockComment && char === '*' && nextChar === '/') {
                    inBlockComment = false;
                    current += char + nextChar;
                    i++; // è·³éä¸‹ä¸€å€‹å­—ç¬¦
                } else if (inBlockComment) {
                    current += char;
                }
                // è™•ç†å¼•è™Ÿ
                else if (!inBlockComment && (char === '"' || char === "'")) {
                    if (!inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                    } else if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = '';
                    }
                    current += char;
                }
                // è™•ç†æ‹¬è™Ÿ
                else if (!inQuotes && !inBlockComment && char === '(') {
                    parens++;
                    current += char;
                } else if (!inQuotes && !inBlockComment && char === ')') {
                    parens--;
                    current += char;
                }
                // è™•ç†é€—è™Ÿåˆ†éš”ç¬¦
                else if (!inQuotes && !inBlockComment && char === ',' && parens === 0) {
                    const trimmedField = current.trim();
                    if (trimmedField) {
                        fields.push(trimmedField);
                    }
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // åŠ å…¥æœ€å¾Œä¸€å€‹æ¬„ä½
            const trimmedField = current.trim();
            if (trimmedField) {
                fields.push(trimmedField);
            }
            
            return fields;
        }

        // é—œéµå­—å¤§å¯«è™•ç†
        function uppercaseKeywords(sql) {
            const keywords = [
                'SELECT', 'FROM', 'WHERE', 'ORDER BY', 'GROUP BY', 'HAVING', 
                'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'ALTER', 'DROP',
                'INNER JOIN', 'LEFT JOIN', 'RIGHT JOIN', 'FULL JOIN', 'JOIN',
                'UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT',
                'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN',
                'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
                'AS', 'IS', 'NULL', 'TRUE', 'FALSE',
                'DISTINCT', 'TOP', 'LIMIT', 'OFFSET',
                'INTO', 'VALUES', 'SET'
            ];
            
            keywords.forEach(keyword => {
                const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                sql = sql.replace(regex, keyword);
            });
            
            return sql;
        }

        // ä¸»è¦æ ¼å¼åŒ–å‡½æ•¸ - ç²¾æº–æ¨™æº–æ ¼å¼
        function formatSqlAdvanced(sql) {
            console.log('é–‹å§‹è™•ç† SQL:', sql);
            
            // å…ˆè™•ç†é—œéµå­—å¤§å¯«
            sql = uppercaseKeywords(sql);
            
            // ä½¿ç”¨æ¨™æº–æ ¼å¼åŒ–å™¨å»ºç«‹åŸºæœ¬çµæ§‹
            try {
                sql = window.sqlFormatter.format(sql, {
                    language: 'sql',
                    keywordCase: 'upper',
                    indentStyle: 'tabbed',
                    logicalOperatorNewline: 'before'
                });
                console.log('æ¨™æº–æ ¼å¼åŒ–å¾Œ:', sql);
            } catch (error) {
                console.warn('æ ¼å¼åŒ–å™¨å¤±æ•—ï¼Œä½¿ç”¨åŸå§‹ SQL');
            }
            
            // ç²¾æº–å¾Œè™•ç† - å®Œå…¨ç¬¦åˆæ¨™æº–æ ¼å¼
            sql = precisionPostProcess(sql);
            
            console.log('æœ€çµ‚çµæœ:', sql);
            return sql;
        }

        // ç²¾æº–å¾Œè™•ç† - å®Œå…¨ç¬¦åˆæ¨™æº–æ ¼å¼
        function precisionPostProcess(sql) {
            const lines = sql.split('\n');
            const result = [];
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trim();
                const upperTrimmed = trimmed.toUpperCase();
                
                // è™•ç† SELECT èªå¥
                if (upperTrimmed === 'SELECT' || upperTrimmed.startsWith('SELECT ')) {
                    const selectResult = processSelectClause(lines, i);
                    result.push(...selectResult.lines);
                    i = selectResult.nextIndex;
                }
                // è™•ç† GROUP BY èªå¥
                else if (upperTrimmed === 'GROUP BY' || upperTrimmed.startsWith('GROUP BY ')) {
                    const groupResult = processGroupByClause(lines, i);
                    result.push(...groupResult.lines);
                    i = groupResult.nextIndex;
                }
                // è™•ç† ORDER BY èªå¥
                else if (upperTrimmed === 'ORDER BY' || upperTrimmed.startsWith('ORDER BY ')) {
                    const orderResult = processOrderByClause(lines, i);
                    result.push(...orderResult.lines);
                    i = orderResult.nextIndex;
                }
                // è™•ç†åŒ…å«å­æŸ¥è©¢çš„è¡Œ
                else if (containsSubquery(line)) {
                    const subqueryResult = processSubqueryLine(line);
                    result.push(...subqueryResult);
                    i++;
                }
                // å…¶ä»–è¡Œç›´æ¥ä¿ç•™
                else {
                    result.push(line);
                    i++;
                }
            }
            
            return result.join('\n');
        }

        // æª¢æŸ¥æ˜¯å¦åŒ…å«å­æŸ¥è©¢
        function containsSubquery(line) {
            return /FROM\s*\(\s*SELECT/i.test(line) || 
                   /JOIN\s*\(\s*SELECT/i.test(line) ||
                   /\(\s*SELECT/i.test(line);
        }

        // è™•ç†åŒ…å«å­æŸ¥è©¢çš„è¡Œ
        function processSubqueryLine(line) {
            const result = [];
            const baseIndent = line.match(/^(\s*)/)[1];
            
            // åŒ¹é… "FROM ( SELECT ..." æ¨¡å¼
            const subqueryMatch = line.match(/^(.+?)\(\s*(SELECT.+)$/i);
            if (subqueryMatch) {
                const beforeSelect = subqueryMatch[1].trim();
                const selectContent = subqueryMatch[2];
                
                // æ·»åŠ  FROM ( éƒ¨åˆ†
                result.push(baseIndent + beforeSelect + '(');
                
                // è™•ç†å­æŸ¥è©¢ SELECT éƒ¨åˆ†
                const subqueryLines = processSubquerySelect(selectContent, baseIndent + '\t');
                result.push(...subqueryLines);
                
                return result;
            }
            
            return [line];
        }

        // è™•ç†å­æŸ¥è©¢ä¸­çš„ SELECT
        function processSubquerySelect(selectContent, baseIndent) {
            const result = [];
            
            // ç§»é™¤å¯èƒ½çš„çµå°¾æ‹¬è™Ÿå’Œå…¶ä»–å…§å®¹
            let cleanSelect = selectContent;
            let remainingContent = '';
            
            // å°‹æ‰¾ FROM é—œéµå­—ä¾†åˆ†é›¢æ¬„ä½éƒ¨åˆ†
            const fromMatch = cleanSelect.match(/^(SELECT\s+.+?)\s+(FROM\s+.+)$/i);
            if (fromMatch) {
                cleanSelect = fromMatch[1];
                remainingContent = fromMatch[2];
            }
            
            // è™•ç† SELECT éƒ¨åˆ†
            const selectMatch = cleanSelect.match(/^(SELECT)\s*(.*)$/i);
            if (selectMatch) {
                result.push(baseIndent + 'SELECT');
                
                const fieldsContent = selectMatch[2].trim();
                if (fieldsContent) {
                    const fields = parseFieldsAdvanced(fieldsContent);
                    
                    fields.forEach((field, index) => {
                        // æª¢æŸ¥æ˜¯å¦æ˜¯ç´”è¨»é‡‹æ¬„ä½ï¼ˆå¦‚ /*1202-3000 å¯è½‰å‚µï¼æˆæœ¬*/ï¼‰
                        if (field.trim().startsWith('/*') && field.trim().endsWith('*/') && !field.includes('AS') && !field.includes('.')) {
                            if (index === 0) {
                                result.push(baseIndent + '\t' + field);
                            } else {
                                result.push(baseIndent + '\t,' + field);
                            }
                        } else {
                            if (index === 0) {
                                result.push(baseIndent + '\t' + field);
                            } else {
                                result.push(baseIndent + '\t,' + field);
                            }
                        }
                    });
                }
            }
            
            // è™•ç†å‰©é¤˜å…§å®¹ï¼ˆFROM ç­‰ï¼‰
            if (remainingContent) {
                const remainingLines = remainingContent.split(/\s+(?=FROM|WHERE|GROUP BY|ORDER BY|HAVING|JOIN|LEFT JOIN|RIGHT JOIN|INNER JOIN)/i);
                remainingLines.forEach(line => {
                    if (line.trim()) {
                        result.push(baseIndent + line.trim());
                    }
                });
            }
            
            return result;
        }

        // è™•ç† SELECT å­å¥
        function processSelectClause(lines, startIndex) {
            const selectLine = lines[startIndex];
            const baseIndent = selectLine.match(/^(\s*)/)[1];
            const result = [];
            
            // SELECT é—œéµå­—
            result.push(baseIndent + 'SELECT');
            
            // æ”¶é›†æ‰€æœ‰ç›¸é—œè¡Œ
            let i = startIndex + 1;
            let allContent = '';
            const commentLines = [];
            
            // è™•ç† SELECT è¡Œæœ¬èº«çš„å…§å®¹
            const selectMatch = selectLine.match(/^\s*SELECT\s*(.*)$/i);
            if (selectMatch && selectMatch[1].trim()) {
                allContent = selectMatch[1].trim();
            }
            
            // æ”¶é›†å¾ŒçºŒè¡Œ
            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trim();
                const upperTrimmed = trimmed.toUpperCase();
                
                // åœæ­¢æ¢ä»¶
                if (trimmed === '' || 
                    upperTrimmed.startsWith('FROM ') || 
                    upperTrimmed.startsWith('WHERE ') ||
                    upperTrimmed.startsWith('GROUP BY') ||
                    upperTrimmed.startsWith('HAVING ') ||
                    upperTrimmed.startsWith('ORDER BY') ||
                    upperTrimmed.startsWith('UNION ') ||
                    upperTrimmed.startsWith('SELECT ') ||
                    upperTrimmed === ')' ||
                    (upperTrimmed.startsWith(')') && upperTrimmed.length > 1)) {
                    break;
                }
                
                // æª¢æŸ¥æ˜¯å¦æ˜¯ç¨ç«‹è¨»é‡‹è¡Œ
                if (trimmed.startsWith('/*') && trimmed.endsWith('*/') && !trimmed.includes(',') && !trimmed.includes('AS')) {
                    commentLines.push({ index: i, content: trimmed, position: allContent ? 'middle' : 'start' });
                } else if (trimmed) {
                    // ç´¯ç©æ¬„ä½å…§å®¹
                    if (allContent) {
                        allContent += ' ' + trimmed;
                    } else {
                        allContent = trimmed;
                    }
                }
                
                i++;
            }
            
            // è™•ç†è¨»é‡‹å’Œæ¬„ä½
            if (commentLines.length > 0 && commentLines[0].position === 'start') {
                // ç¬¬ä¸€å€‹æ˜¯è¨»é‡‹è¡Œ
                result.push(baseIndent + '\t' + commentLines[0].content);
                commentLines.shift();
            }
            
            // è™•ç†æ¬„ä½
            if (allContent.trim()) {
                const fields = parseFieldsAdvanced(allContent);
                
                fields.forEach((field, index) => {
                    // æª¢æŸ¥æ˜¯å¦éœ€è¦æ’å…¥ä¸­é–“è¨»é‡‹
                    const middleComments = commentLines.filter(c => c.position === 'middle');
                    if (middleComments.length > 0 && index === Math.floor(fields.length / 2)) {
                        result.push(baseIndent + '\t' + middleComments[0].content);
                    }
                    
                    if (index === 0) {
                        result.push(baseIndent + '\t' + field);
                    } else {
                        result.push(baseIndent + '\t,' + field);
                    }
                });
            }
            
            // è™•ç†å‰©é¤˜çš„è¨»é‡‹è¡Œ
            commentLines.forEach(comment => {
                if (comment.position === 'middle') {
                    result.push(baseIndent + '\t' + comment.content);
                }
            });
            
            return {
                lines: result,
                nextIndex: i
            };
        }

        // è™•ç† GROUP BY å­å¥
        function processGroupByClause(lines, startIndex) {
            return processFieldsClause(lines, startIndex, 'GROUP BY');
        }

        // è™•ç† ORDER BY å­å¥
        function processOrderByClause(lines, startIndex) {
            return processFieldsClause(lines, startIndex, 'ORDER BY');
        }

        // çµ±ä¸€è™•ç†æ¬„ä½å­å¥
        function processFieldsClause(lines, startIndex, keyword) {
            const line = lines[startIndex];
            const baseIndent = line.match(/^(\s*)/)[1];
            const result = [baseIndent + keyword];
            
            // æå–é—œéµå­—å¾Œçš„å…§å®¹
            const regex = new RegExp(`^\\s*(${keyword})\\s*(.*)$`, 'i');
            const match = line.match(regex);
            
            let content = '';
            if (match && match[2].trim()) {
                content = match[2].trim();
            }
            
            // æ”¶é›†å¤šè¡Œå…§å®¹
            let i = startIndex + 1;
            const stopKeywords = ['ORDER BY', 'GROUP BY', 'HAVING', 'UNION', 'SELECT', ')'];
            
            while (i < lines.length) {
                const nextLine = lines[i];
                const nextTrimmed = nextLine.trim();
                
                if (nextTrimmed === '' || stopKeywords.some(kw => nextTrimmed.toUpperCase().startsWith(kw))) {
                    break;
                }
                
                if (nextTrimmed) {
                    content += (content ? ' ' : '') + nextTrimmed;
                }
                i++;
            }
            
            // è™•ç†æ¬„ä½
            if (content.trim()) {
                const fields = parseFieldsAdvanced(content);
                fields.forEach((field, index) => {
                    if (index === 0) {
                        result.push(baseIndent + '\t' + field);
                    } else {
                        result.push(baseIndent + '\t,' + field);
                    }
                });
            }
            
            return {
                lines: result,
                nextIndex: i
            };
        }

        function initializeAddSbAppendTool() {
            const convertBtn = document.getElementById('convertSqlBtn');
            const formatOnlyBtn = document.getElementById('formatOnlyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyButtons = document.querySelectorAll('.copy-button');
            
            if (convertBtn) convertBtn.addEventListener('click', convertSql);
            if (formatOnlyBtn) formatOnlyBtn.addEventListener('click', formatSqlOnly);
            if (clearBtn) clearBtn.addEventListener('click', clearAll);
            
            copyButtons.forEach(button => {
                const targetId = button.dataset.copyTarget;
                if (targetId) {
                    button.addEventListener('click', () => copyToClipboard(targetId));
                }
            });
        }

        // åƒ…æ ¼å¼åŒ– SQL
        function formatSqlOnly() {
            const sqlInput = document.getElementById('sqlInput');
            const sql = sqlInput.value.trim();
            
            if (!sql) {
                alert('è«‹å…ˆè¼¸å…¥ SQL èªå¥');
                return;
            }
            
            const formattedSql = formatSqlAdvanced(sql);
            sqlInput.value = formattedSql;
        }

        // æ¸…ç©ºæ‰€æœ‰å…§å®¹
        function clearAll() {
            document.getElementById('sqlInput').value = '';
            document.getElementById('sbAppendOutput').textContent = 'sb.append() çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º...';
            document.getElementById('hibernateOutput').textContent = 'HibernateScalarHelper çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º...';
            document.getElementById('camelCaseAsCheckbox').checked = false;
            document.getElementById('hibernateCheckbox').checked = false;
        }

        // é§å³°å‘½åè½‰æ›
        function toCamelCase(str) {
            return str.split('_').map((word, index) => {
                if (index === 0) {
                    return word.toLowerCase();
                }
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }).join('');
        }

        // æª¢æŸ¥æ˜¯å¦ç‚º nam ç›¸é—œæ¬„ä½
        function isNamField(fieldName) {
            const lowerFieldName = fieldName.toLowerCase();
            return lowerFieldName.includes('nam') || 
                   lowerFieldName.includes('name') ||
                   lowerFieldName.startsWith('nam_') ||
                   lowerFieldName.endsWith('_nam') ||
                   lowerFieldName.startsWith('name_') ||
                   lowerFieldName.endsWith('_name');
        }

        // æå–è¨»é‡‹
        function extractComments(line) {
            const result = {
                code: line,
                comment: '',
                hasComment: false
            };

            // è™•ç† -- è¨»é‡‹
            const singleLineCommentMatch = line.match(/^(.*?)--(.*)$/);
            if (singleLineCommentMatch) {
                result.code = singleLineCommentMatch[1].trimEnd();
                result.comment = singleLineCommentMatch[2].trim();
                result.hasComment = true;
            }

            return result;
        }

        // è§£æ SELECT æ¬„ä½ï¼ˆç”¨æ–¼ Hibernateï¼‰
        function parseSelectFields(sql) {
            try {
                let cleanSql = sql.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
                
                const selectMatch = cleanSql.match(/\bSELECT\s+([\s\S]+?)(?:\s+FROM\b|\s+INTO\b|\s*$)/i);
                
                if (!selectMatch) {
                    return [];
                }
                
                const fieldsText = selectMatch[1].trim();
                return parseFieldsAdvanced(fieldsText);
            } catch (error) {
                console.error('è§£æ SELECT æ¬„ä½æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                return [];
            }
        }

        // è™•ç†é§å³°å‘½å
        function addCamelCaseAS(sql) {
            const lines = sql.split('\n');
            let inSelectClause = false;
            
            const processedLines = lines.map(line => {
                const trimmed = line.trim().toUpperCase();
                
                if (trimmed.startsWith('SELECT')) {
                    inSelectClause = true;
                } else if (inSelectClause && (trimmed.startsWith('FROM') || trimmed.startsWith('WHERE') || trimmed.startsWith('GROUP BY'))) {
                    inSelectClause = false;
                }
                
                if (inSelectClause && !trimmed.startsWith('SELECT') && trimmed !== '') {
                    return processSelectLine(line);
                }
                
                return line;
            });
            
            return processedLines.join('\n');
        }

        function processSelectLine(line) {
            const commentInfo = extractComments(line);
            let codePart = commentInfo.code;
            const indent = line.match(/^(\s*)/)[1];
            const cleanCode = codePart.trim();
            
            if (cleanCode.toUpperCase().includes(' AS ')) {
                return line;
            }
            
            // æª¢æŸ¥æ˜¯å¦ä»¥é€—è™Ÿé–‹é ­
            let processedCode = cleanCode.replace(/^,\s*/, '');
            const hasComma = cleanCode.startsWith(',');
            
            const fields = parseFieldsAdvanced(processedCode);
            const processedFields = fields.map(field => processField(field.trim()));
            
            let result = processedFields.join(', ');
            if (hasComma) {
                result = ',' + result;
            }
            
            let finalResult = indent + result;
            
            if (commentInfo.hasComment) {
                finalResult += ' --' + commentInfo.comment;
            }
            
            return finalResult;
        }

        function processField(fieldText) {
            if (fieldText.toUpperCase().includes(' AS ')) {
                return fieldText;
            }
            
            let fieldName = fieldText;
            
            const functionMatch = fieldName.match(/(\w+)\s*\(\s*([^)]+)\s*\)/);
            if (functionMatch) {
                const innerContent = functionMatch[2].trim();
                if (innerContent.includes('.')) {
                    fieldName = innerContent.split('.').pop();
                } else {
                    fieldName = innerContent;
                }
            } else if (fieldName.includes('.')) {
                fieldName = fieldName.split('.').pop();
            }
            
            fieldName = fieldName.replace(/[^\w]/g, '');
            
            if (!isNamField(fieldName) && fieldName.includes('_')) {
                const camelCaseName = toCamelCase(fieldName);
                return `${fieldText} AS ${camelCaseName}`;
            }
            
            return fieldText;
        }

        // ä¸»è¦è½‰æ›å‡½æ•¸
        function convertSql() {
            let sql = document.getElementById("sqlInput")?.value || "";
            const useCamelCaseAs = document.getElementById('camelCaseAsCheckbox')?.checked || false;
            const generateHibernate = document.getElementById('hibernateCheckbox')?.checked || false;
            
            if (!sql.trim()) {
                alert("è«‹è¼¸å…¥ SQL èªå¥");
                return;
            }
            
            console.log('åŸå§‹ SQL:', sql);
            
            // 1. æ ¼å¼åŒ– SQL
            sql = formatSqlAdvanced(sql);
            console.log('æ ¼å¼åŒ–å¾Œ SQL:', sql);
            
            // 2. å¦‚æœå•Ÿç”¨é§å³°å‘½åï¼Œè™•ç† AS åˆ¥å
            if (useCamelCaseAs) {
                sql = addCamelCaseAS(sql);
                console.log('é§å³°è™•ç†å¾Œ SQL:', sql);
            }
            
            // 3. è½‰æ›ç‚º sb.append() æ ¼å¼
            const lines = sql.split('\n');
            const sbAppendResult = [];
            
            lines.forEach(line => {
                if (!line.trim()) return;
                
                const commentInfo = extractComments(line);
                const code = commentInfo.code.trim();
                
                if (code) {
                    const escapedCode = code.replace(/"/g, '\\"');
                    const originalIndent = line.match(/^(\s*)/)[1];
                    let appendStatement = `sb.append("${originalIndent}${escapedCode} ");`;
                    
                    if (commentInfo.hasComment && commentInfo.comment) {
                        appendStatement += ` // ${commentInfo.comment}`;
                    }
                    
                    sbAppendResult.push(appendStatement);
                }
            });
            
            console.log('sb.append çµæœ:', sbAppendResult);
            document.getElementById("sbAppendOutput").textContent = sbAppendResult.join('\n');
            
            // 4. ç”Ÿæˆ HibernateScalarHelper
            if (generateHibernate) {
                generateHibernateHelper(sql);
            } else {
                document.getElementById("hibernateOutput").textContent = "è«‹å‹¾é¸ã€Œç”¢ç”Ÿ HibernateScalarHelperã€é¸é …";
            }
        }

        function generateHibernateHelper(sql) {
            try {
                const selectFields = parseSelectFields(sql);
                
                if (selectFields.length === 0) {
                    document.getElementById("hibernateOutput").textContent = "ç„¡æ³•è­˜åˆ¥ SELECT èªå¥ï¼Œè«‹æª¢æŸ¥ SQL æ ¼å¼";
                    return;
                }
                
                const fields = selectFields.map(field => {
                    const trimmed = field.trim();
                    const commentInfo = extractComments(trimmed);
                    const cleanField = commentInfo.code.trim();
                    
                    const asMatch = cleanField.match(/\s+AS\s+(\w+)/i);
                    if (asMatch) {
                        return asMatch[1];
                    }
                    
                    let fieldName = cleanField;
                    
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop();
                    }
                    
                    fieldName = fieldName.replace(/[^\w]/g, '');
                    
                    return fieldName;
                }).filter(field => field && field.trim() !== '');
                
                if (fields.length > 0) {
                    const hibernateList = fields.map(field => 
                        `scalarList.add(new HibernateScalarHelper("${field}", StandardBasicTypes.STRING));`
                    ).join('\n');
                    
                    const hibernateResult = `List<HibernateScalarHelper> scalarList = new ArrayList<>();\n${hibernateList}`;
                    document.getElementById("hibernateOutput").textContent = hibernateResult;
                } else {
                    document.getElementById("hibernateOutput").textContent = "ç„¡æ³•æå–åˆ°æœ‰æ•ˆçš„æ¬„ä½å";
                }
            } catch (error) {
                console.error('ç”Ÿæˆ HibernateScalarHelper æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                document.getElementById("hibernateOutput").textContent = "ç”Ÿæˆ HibernateScalarHelper æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š" + error.message;
            }
        }

        function copyToClipboard(id) {
            const element = document.getElementById(id);
            if (element) {
                const text = element.textContent;
                if (text && !text.includes("å°‡åœ¨é€™è£¡é¡¯ç¤º") && !text.includes("è«‹å‹¾é¸")) {
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            const btn = document.querySelector(`[data-copy-target="${id}"]`);
                            const originalText = btn.textContent;
                            btn.textContent = 'âœ… å·²è¤‡è£½ï¼';
                            btn.style.background = 'linear-gradient(135deg, #16a34a 0%, #22c55e 100%)';
                            
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.style.background = '';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('è¤‡è£½å¤±æ•—:', err);
                            alert("è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½");
                        });
                } else {
                    alert("æ²’æœ‰å¯è¤‡è£½çš„å…§å®¹");
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initializeAddSbAppendTool();
        });
    </script>
</body>
</html>